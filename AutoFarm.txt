-- Services
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local VirtualUser = game:GetService("VirtualUser")

if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- === DEVICE DETECTION & SCALING ===
local isMobile = UserInputService.TouchEnabled
local SCALE_MULTIPLIER = isMobile and 1.3 or 1.0

-- Color Settings
local COLOR_SETTINGS = {
    MainBackground = Color3.fromRGB(22, 204, 204),
    TextColor = Color3.fromRGB(0, 0, 0),
    LabelBackground = Color3.fromRGB(22, 162, 204),
    IconCircle = Color3.fromRGB(22, 162, 204),
    AntiAFKActive = Color3.fromRGB(26, 173, 16),
    AntiAFKInactive = Color3.fromRGB(200, 0, 0),
    ToggleOff = Color3.fromRGB(50, 90, 160),
    ToggleOn = Color3.fromRGB(70, 130, 230),
    ToggleCircleOff = Color3.fromRGB(100, 160, 255),
    ToggleCircleOn = Color3.fromRGB(30, 70, 140),
    TitleColor = Color3.fromRGB(0, 0, 0),
    ToggleButtonBackground = Color3.fromRGB(255, 255, 255)
}

-- General settings (Scaled)
local BACKGROUND_TRANSPARENCY = 0.04
local LABEL_BG_TRANSPARENCY = 0.7
local LABEL_BG_HEIGHT = 30 * SCALE_MULTIPLIER
local LABEL_BG_CORNER_RADIUS = 15 * SCALE_MULTIPLIER
local LABEL_FONT_SIZE = 18 * SCALE_MULTIPLIER

-- Decreased top margin (was 45)
local TOGGLE_TOP_MARGIN = 35 * SCALE_MULTIPLIER 
local ROW_SPACING = 4 * SCALE_MULTIPLIER -- Slightly denser rows

local TOGGLE_WIDTH = 60 * SCALE_MULTIPLIER
local TOGGLE_HEIGHT = 28 * SCALE_MULTIPLIER
local TOGGLE_CIRCLE_SIZE = 22 * SCALE_MULTIPLIER
local TOGGLE_CORNER_RADIUS = TOGGLE_HEIGHT/2
local TOGGLE_ANIMATION_TIME = 0.2
local LABEL_WIDTH_ADJUST = 30 * SCALE_MULTIPLIER
local ICON_SIZE = 18 * SCALE_MULTIPLIER
local ICON_CIRCLE_SIZE = LABEL_BG_HEIGHT

-- GUI window sizes (Scaled)
local MAIN_FRAME_WIDTH = 260 * SCALE_MULTIPLIER
local TOGGLE_BUTTON_SIZE = 40 * SCALE_MULTIPLIER
local MINIMUM_FRAME_WIDTH = 200 * SCALE_MULTIPLIER

-- Font settings
local MAIN_FONT = Enum.Font.SourceSansBold

-- Game settings
local FARM_SPEED = 22
local EVENT_CURRENCY = "SnowToken"

-- Timing settings
local NEW_FARM_COLLECT_TIME = 0.25 
local NEW_FARM_REST_TIME = 2

-- === LOBBY CHECK SETTINGS ===
local LOBBY_SPAWN_POINT = Vector3.new(-5082.51, 281.79, 64.05)
local LOBBY_SAFE_RADIUS = 350

-- Icons
local ICON_CIRCLE_OFFSETS = {
    ["[Tween] Event Farm"] = 0,
    ["[Teleport] Event Farm"] = 0,
    ["Disable Rendering"] = 0
}

local ASSET_IDS = {
    ["[Tween] Event Farm"] = 83772946070955,
    ["[Teleport] Event Farm"] = 83772946070955,
    ["Disable Rendering"] = 88413977788163
}

-- Variables
local coinsCollected = 0
local EventFarmStarted = false
local EventFarmIN = false
local eventfarmstopevent = Instance.new("BindableEvent")

local NewEventFarmStarted = false
local NewEventFarmIN = false
local neweventfarmstopevent = Instance.new("BindableEvent")

local renderDisabled = false
local renderStartTime = 0
local blackScreenFrame = nil

local FinishedFarmingRound = false 

-- === NEW VARIABLES ===
local GunAttempted = false -- Gun pickup blocker
local HasDied = false -- Death flag for fling
-- =========================

local isFirstTween = true
local bigPlatform = nil 
local smallPlatform = nil
local platformFollowConnection = nil
local noclipConnection = nil
local newNoclipConnection = nil
local antiAFKConnection = nil
local AntiAFKEnabled = false

-- Fling Variables
getgenv().OldPos = nil
getgenv().FPDH = Workspace.FallenPartsDestroyHeight

-- === HELPER FUNCTIONS ===

local function returncoincontaier()
    for _, v in Workspace:GetChildren() do
        if v:FindFirstChild("CoinContainer") and v:IsA("Model") then
            local container = v:FindFirstChild("CoinContainer")
            if container and #container:GetChildren() > 0 then
                return container
            end
        end
    end
    return false
end

local function isPlayerInLobby()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    local dist = (player.Character.HumanoidRootPart.Position - LOBBY_SPAWN_POINT).Magnitude
    return dist < LOBBY_SAFE_RADIUS
end

-- === ROLE DETECTION ===

local function GetPlayerData()
    local success, roles = pcall(function() 
        return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer() 
    end)
    return success and roles or nil
end

local function GetMurderer()
    local roles = GetPlayerData()
    if roles then
        for i, v in pairs(roles) do
            if v.Role == "Murderer" then
                return Players:FindFirstChild(i)
            end
        end
    end
    return nil
end

local function GetSheriff()
    local roles = GetPlayerData()
    if roles then
        for i, v in pairs(roles) do
            if v.Role == "Sheriff" then
                return Players:FindFirstChild(i)
            end
        end
    end
    return nil
end

-- === FLING LOGIC ===

local function SkidFling(TargetPlayer, FlingDuration)
    if not TargetPlayer then return end
    
    local Character = player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart
    
    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter and TCharacter:FindFirstChild("Head")
    
    if not Character or not Humanoid or not RootPart then return end
    if not TCharacter or not TRootPart then return end
    
    getgenv().OldPos = RootPart.CFrame
    Workspace.FallenPartsDestroyHeight = 0/0
    
    local BV = Instance.new("BodyVelocity")
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(0, 0, 0)
    BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    
    local FPos = function(BasePart, Pos, Ang)
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
        Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
        RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end
    
    local SFBasePart = function(BasePart)
        local TimeToWait = FlingDuration or 1.5 
        local Time = tick()
        local Angle = 0
    
        repeat
            if RootPart and THumanoid then
                if BasePart.Velocity.Magnitude < 50 then
                    Angle = Angle + 100
                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle),0 ,0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()
                else
                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()
                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                    task.wait()
                end
            end
        until Time + TimeToWait < tick()
    end
    
    if TRootPart then
        SFBasePart(TRootPart)
    elseif THead then
        SFBasePart(THead)
    end
    
    if BV then BV:Destroy() end
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    
    if getgenv().OldPos then
        RootPart.CFrame = getgenv().OldPos
        Character:SetPrimaryPartCFrame(getgenv().OldPos)
        Humanoid:ChangeState("GettingUp")
        for _, part in pairs(Character:GetChildren()) do
             if part:IsA("BasePart") then
                 part.Velocity, part.RotVelocity = Vector3.new(), Vector3.new()
             end
        end
        Workspace.FallenPartsDestroyHeight = getgenv().FPDH
    end
end

local function TriggerFlingSequence(role, durationOverride)
    local target = nil
    local duration = durationOverride or 1.5

    if role == "Murderer" then
        target = GetMurderer()
    elseif role == "Sheriff" then
        target = GetSheriff()
    end

    if target and target ~= player then
        SkidFling(target, duration)
    end
end

-- === AUTO GET GUN LOGIC ===

local function getNearestGun()
	local char = player.Character
	if not char then return nil end
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return nil end

	local closestGun, closestDist = nil, 5000
	for _, item in ipairs(Workspace:GetDescendants()) do
		if item.Name == "GunDrop" then
			local success, pos = pcall(function() return item:GetPivot().Position end)
			if success then
				local dist = (root.Position - pos).Magnitude
				if dist < closestDist then
					closestGun, closestDist = item, dist
				end
			end
		end
	end
	return closestGun
end

local function processAutoGun(farmType)
    -- === ATTEMPT CHECK ===
    if GunAttempted then return false end
    -- ===========================

    local char = player.Character
    if char and (char:FindFirstChild("Gun") or (player.Backpack and player.Backpack:FindFirstChild("Gun"))) then
        GunAttempted = true -- Already have gun
        return false 
    end

    local gun = getNearestGun()
    if gun then
        GunAttempted = true -- Mark as attempted immediately if gun found
        
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            -- Logic for Teleport Farm
            if farmType == "Teleport" then
                -- 1. Secure on platform first
                if bigPlatform then
                    hrp.CFrame = CFrame.new(bigPlatform.Position + Vector3.new(0, 5, 0))
                    task.wait(0.2)
                end
               
                -- 2. Teleport to Gun
                hrp.AssemblyLinearVelocity = Vector3.zero
                local gunPos = gun:GetPivot().Position
                hrp.CFrame = CFrame.new(gunPos + Vector3.new(0, 1, 0))
                
                local timeout = tick() + 1
                while gun:IsDescendantOf(Workspace) and tick() < timeout do
                    task.wait(0.1)
                    if gun:IsDescendantOf(Workspace) then
                        hrp.CFrame = CFrame.new(gun:GetPivot().Position) -- Force collect
                    end
                end
                
                -- 3. Return to platform immediately handled by main loop
                return true
                
            -- Logic for Tween Farm
            elseif farmType == "Tween" then
                -- 1. Pause Tween (Handled by caller cancelling tween)
                hrp.AssemblyLinearVelocity = Vector3.zero
                
                -- 2. Tween to Gun
                local gunPos = gun:GetPivot().Position
                local dist = (hrp.Position - gunPos).Magnitude
                local gunTween = TweenService:Create(hrp, TweenInfo.new(dist / (FARM_SPEED * 1.5), Enum.EasingStyle.Linear), {CFrame = CFrame.new(gunPos)})
                gunTween:Play()
                gunTween.Completed:Wait()
                
                local timeout = tick() + 1
                while gun:IsDescendantOf(Workspace) and tick() < timeout do
                    task.wait(0.1)
                    hrp.CFrame = CFrame.new(gun:GetPivot().Position)
                end
                return true
            end
        end
    end
    return false
end

-- === PLATFORM FUNCTIONS ===

local function createBigPlatform()
    if bigPlatform then bigPlatform:Destroy() bigPlatform = nil end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return nil end
    
    local hrp = player.Character.HumanoidRootPart
    local bigSizeValue = 750
    local bigSize = Vector3.new(bigSizeValue, 1, bigSizeValue)
    local deepOffset = 15 * 6
    
    bigPlatform = Instance.new("Part")
    bigPlatform.Name = "FrozenBase_Mega"
    bigPlatform.Size = bigSize
    bigPlatform.Position = hrp.Position - Vector3.new(0, deepOffset, 0)
    bigPlatform.Anchored = true
    bigPlatform.CanCollide = true
    bigPlatform.BrickColor = BrickColor.new("White")
    bigPlatform.Transparency = 0.5
    bigPlatform.Material = Enum.Material.SmoothPlastic
    bigPlatform.Parent = Workspace
    
    local tex1 = Instance.new("Texture")
    tex1.Texture = "rbxassetid://7365408"
    tex1.Face = Enum.NormalId.Top
    tex1.StudsPerTileU, tex1.StudsPerTileV = 2, 2
    tex1.Parent = bigPlatform
    
    return bigPlatform
end

local function createSmallPlatform()
    if smallPlatform then smallPlatform:Destroy() smallPlatform = nil end
    
    smallPlatform = Instance.new("Part")
    smallPlatform.Name = "FollowPlatform_Small"
    smallPlatform.Size = Vector3.new(6, 0.5, 6)
    smallPlatform.BrickColor = BrickColor.new("White")
    smallPlatform.Transparency = 0.5
    smallPlatform.Anchored = true
    smallPlatform.CanCollide = true
    smallPlatform.Material = Enum.Material.SmoothPlastic
    smallPlatform.Parent = Workspace
    
    local tex2 = Instance.new("Texture")
    tex2.Texture = "rbxassetid://7365408"
    tex2.Face = Enum.NormalId.Top
    tex2.Parent = smallPlatform
    
    return smallPlatform
end

local function startPlatformFollowing()
    if platformFollowConnection then platformFollowConnection:Disconnect() end
    local followOffset = Vector3.new(0, -3.5, 0)
    
    platformFollowConnection = RunService.RenderStepped:Connect(function()
        if not smallPlatform or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
        local hrp = player.Character.HumanoidRootPart
        smallPlatform.CFrame = CFrame.new(hrp.Position + followOffset)
    end)
end

local function removeAllPlatforms()
    if platformFollowConnection then
        platformFollowConnection:Disconnect()
        platformFollowConnection = nil
    end
    if bigPlatform then bigPlatform:Destroy() bigPlatform = nil end
    if smallPlatform then smallPlatform:Destroy() smallPlatform = nil end
end

local function teleportToBigPlatform()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or not bigPlatform then return false end
    
    local hrp = player.Character.HumanoidRootPart
    local platformPos = bigPlatform.Position
    local platformSurfaceY = platformPos.Y + (bigPlatform.Size.Y / 2) + 3
    
    hrp.CFrame = CFrame.new(Vector3.new(platformPos.X, platformSurfaceY, platformPos.Z))
    return true
end

-- NoClip system
local function setupFarmNoClip(enabled, isNew)
    local function setCollision(canCollideState)
        if player.Character then
            for _, v in pairs(player.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = canCollideState
                end
            end
        end
    end

    if isNew then
        if newNoclipConnection then newNoclipConnection:Disconnect() newNoclipConnection = nil end
        if enabled then
            newNoclipConnection = RunService.Stepped:Connect(function()
                if NewEventFarmStarted and NewEventFarmIN and player.Character then
                    setCollision(false)
                end
            end)
        else
            setCollision(true)
        end
    else
        if noclipConnection then noclipConnection:Disconnect() noclipConnection = nil end
        if enabled then
            noclipConnection = RunService.Stepped:Connect(function()
                if EventFarmStarted and EventFarmIN and player.Character then
                    setCollision(false)
                end
            end)
        else
            setCollision(true)
        end
    end
end

-- Farm Logic (Teleport with Smooth Downward Motion)
local function teleportToCoinAndBack(coinPosition)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    
    local hrp = player.Character.HumanoidRootPart
    
    -- 1. TELEPORT SLIGHTLY ABOVE (3 studs)
    local startHeightOffset = Vector3.new(0, 3, 0) 
    hrp.CFrame = CFrame.new(coinPosition + startHeightOffset)
    
    setupFarmNoClip(true, true)
    
    -- 2. TWEEN DOWN TO CENTER (0 studs) - Soft movement
    local tweenInfo = TweenInfo.new(NEW_FARM_COLLECT_TIME, Enum.EasingStyle.Linear)
    local targetCFrame = CFrame.new(coinPosition) 
    
    local moveTween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    moveTween:Play()
    
    local startFall = tick()
    while tick() - startFall < NEW_FARM_COLLECT_TIME do
        if not NewEventFarmIN then 
            moveTween:Cancel()
            return 
        end
        task.wait(0.05)
    end
    
    -- 3. RETURN TO BASE
    moveTween:Cancel()
    hrp.AssemblyLinearVelocity = Vector3.zero
    hrp.AssemblyAngularVelocity = Vector3.zero
    
    if not bigPlatform then createBigPlatform() end

    setupFarmNoClip(false, true)

    local safelyOnPlatform = false
    local attempts = 0
    
    while not safelyOnPlatform and attempts < 10 do
        teleportToBigPlatform()
        task.wait(0.1) 
        if bigPlatform then
            local dist = (hrp.Position - Vector3.new(bigPlatform.Position.X, hrp.Position.Y, bigPlatform.Position.Z)).Magnitude
            if dist < 50 then 
                safelyOnPlatform = true
            end
        end
        attempts = attempts + 1
    end
    
    -- 4. REST & CHECK GUN
    local startWait = tick()
    while tick() - startWait < NEW_FARM_REST_TIME do
        if not NewEventFarmIN then break end
        
        -- Check Gun during rest
        if processAutoGun("Teleport") then
             -- If we got gun, logic inside processed it. Break wait to continue farming immediately.
             break
        end
        
        task.wait(0.1)
    end
end

-- Anti-AFK system
local function SetupAntiAFK(enabled)
    AntiAFKEnabled = enabled
    if enabled then
        local GC = getconnections or get_signal_cons
        if type(GC) == "function" then
            local success, connections = pcall(function() return GC(game.Players.LocalPlayer.Idled) end)
            if success and connections then
                for i, v in pairs(connections) do
                    if v and (v["Disable"] or v["Disconnect"]) then
                        if v["Disable"] then pcall(function() v["Disable"](v) end)
                        elseif v["Disconnect"] then pcall(function() v["Disconnect"](v) end) end
                    end
                end
                return
            end
        end
        
        if antiAFKConnection then antiAFKConnection:Disconnect() end
        antiAFKConnection = game.Players.LocalPlayer.Idled:Connect(function()
            if AntiAFKEnabled then
                pcall(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                end)
            end
        end)
    else
        if antiAFKConnection then antiAFKConnection:Disconnect() antiAFKConnection = nil end
    end
end

-- Character death/respawn handling
local function handleCharacterDeath(isNew)
    if isNew then
        if NewEventFarmStarted then
            NewEventFarmIN = false
            neweventfarmstopevent:Fire()
            setupFarmNoClip(false, true)
            removeAllPlatforms()
        end
    else
        if EventFarmStarted then
            EventFarmIN = false
            eventfarmstopevent:Fire()
            setupFarmNoClip(false, false)
        end
    end
end

local function killCharacter()
    local char = player.Character
    if char then char:BreakJoints() return true end
    return false
end

local function monitorCharacterDeath()
    local function onCharacterAdded(char)
        local humanoid = char:WaitForChild("Humanoid", 10)
        
        -- === NEW LOGIC: FLING AFTER DEATH (RESPAWN) ===
        if HasDied then
            task.spawn(function()
                task.wait(2) -- Wait for character load
                TriggerFlingSequence("Murderer", 1.5)
                HasDied = false -- Reset death flag
            end)
        end
        -- ==================================================

        if humanoid then
            humanoid.Died:Connect(function()
                HasDied = true -- Register death
                handleCharacterDeath(false)
                handleCharacterDeath(true)
            end)
        end
        
        char:GetAttributeChangedSignal("Alive"):Connect(function()
            if char:GetAttribute("Alive") == false then
                HasDied = true -- Register death
                handleCharacterDeath(false)
                handleCharacterDeath(true)
            end
        end)
        
        -- === LOGIC AFTER RESET (FULL BAG) ===
        if FinishedFarmingRound then
            task.spawn(function()
                task.wait(2) -- Wait for character to load properly
                
                -- 3 Attempts to Fling Murderer
                for i = 1, 3 do
                    TriggerFlingSequence("Murderer", 1.5)
                    task.wait(1.8)
                end
                
                FinishedFarmingRound = false -- Reset flag
                
                -- Reset AGAIN to wait for next round fresh
                killCharacter()
            end)
            return -- Stop here, don't restart farm yet
        end
        
        task.wait(2)
        
        if isPlayerInLobby() then
            EventFarmIN = false
            NewEventFarmIN = false
            return 
        end
        
        if EventFarmStarted then
            if returncoincontaier() then
                 EventFarmIN = true 
                 setupFarmNoClip(true, false) 
            else
                 EventFarmIN = false
            end
        end
        
        if NewEventFarmStarted then
            if returncoincontaier() then
                NewEventFarmIN = true
                createBigPlatform()
                createSmallPlatform()
                startPlatformFollowing()
                task.wait(0.5)
                teleportToBigPlatform()
            else
                NewEventFarmIN = false
            end
        end
    end
    
    if player.Character then onCharacterAdded(player.Character) end
    player.CharacterAdded:Connect(onCharacterAdded)
end

monitorCharacterDeath()

-- Coin container logic
local CoinCollectedEvent = ReplicatedStorage.Remotes.Gameplay.CoinCollected
local RoundStartEvent = ReplicatedStorage.Remotes.Gameplay.RoundStart
local RoundEndEvent = ReplicatedStorage.Remotes.Gameplay.RoundEndFade

local function FindNearestCoin(container, coinType)
    local coin = nil
    local magn = math.huge
    for _, v in pairs(container:GetChildren()) do
        if v:GetAttribute("CoinID") == coinType and v:FindFirstChild("TouchInterest") then
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - v.Position).Magnitude
                if distance < magn then
                    coin = v
                    magn = distance
                end
            end
        end
    end
    return {coin, magn}
end

-- Events
CoinCollectedEvent.OnClientEvent:Connect(function(cointype, current, max)
    local bagFull = (tonumber(current) == tonumber(max))
    
    local function StopAndReset()
        EventFarmIN = false
        NewEventFarmIN = false
        setupFarmNoClip(false, false)
        setupFarmNoClip(false, true)
        removeAllPlatforms()
        
        FinishedFarmingRound = true -- Set Flag for next Respawn
        killCharacter() -- Auto Reset
    end

    if EventFarmStarted and EventFarmIN then
        if cointype == EVENT_CURRENCY then
            coinsCollected = coinsCollected + 1
        end
        if cointype == EVENT_CURRENCY and bagFull then
            StopAndReset()
        end
    end

    if NewEventFarmStarted and NewEventFarmIN then
        if cointype == EVENT_CURRENCY then
            coinsCollected = coinsCollected + 1
        end
        if cointype == EVENT_CURRENCY and bagFull then
            StopAndReset()
        end
    end
end)

-- === UPDATED ROUND START LOGIC (FLING IF NO COINS) ===
RoundStartEvent.OnClientEvent:Connect(function()
    GunAttempted = false -- RESET GUN PICKUP ATTEMPT FOR NEW ROUND

    if EventFarmStarted or NewEventFarmStarted then
        
        -- === 1. SHERIFF FLING (Kept as is) ===
        task.spawn(function()
            task.wait(1) 
            TriggerFlingSequence("Sheriff", 2.0) -- Fling Sheriff 2 sec
        end)
        
        task.wait(3.5) -- Wait for sheriff fling to end

        -- === 2. SPECIAL MODE CHECK (NO COINS) ===
        local coinContainer = returncoincontaier()

        if not coinContainer then
            -- NO COINS: Start mass fling
            local originalPos = nil
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                originalPos = player.Character.HumanoidRootPart.CFrame
            end

            -- Iterate all players
            for _, target in pairs(Players:GetPlayers()) do
                if target ~= player and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                    -- Check if local char is alive before attack
                    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then break end
                    
                    -- Fling player 1.5 seconds
                    SkidFling(target, 1.5)
                end
            end

            -- Return to original position
            if originalPos and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CFrame = originalPos
                player.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero
                player.Character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero
            end

        else
            -- COINS EXIST: Start normal farm
            if EventFarmStarted then
                EventFarmIN = true
                isFirstTween = true 
                setupFarmNoClip(true, false)
            end
            
            if NewEventFarmStarted then
                NewEventFarmIN = true
                createBigPlatform()
                createSmallPlatform()
                startPlatformFollowing()
                task.wait(0.5)
                teleportToBigPlatform()
            end
        end
    end
end)

RoundEndEvent.OnClientEvent:Connect(function()
    EventFarmIN = false
    NewEventFarmIN = false
    setupFarmNoClip(false, false)
    setupFarmNoClip(false, true)
    removeAllPlatforms()
end)

-- Tween Farm Loop
task.spawn(function()
    while true do
        if EventFarmStarted and isPlayerInLobby() then
            EventFarmIN = false
            setupFarmNoClip(false, false)
            task.wait(1)
        end

        local container = returncoincontaier()
        if EventFarmStarted and EventFarmIN and player.Character and container and player:GetAttribute("Alive") then
            
            -- Check Gun (Pass "Tween" type)
            if processAutoGun("Tween") then
                -- Resume loop
            end
            
            local coinData = FindNearestCoin(container, EVENT_CURRENCY)
            if coinData[1] ~= nil then
                if isFirstTween then
                    -- Initial TP above
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(coinData[1].Position + Vector3.new(0,2,0))
                    isFirstTween = false
                    local startWait = tick()
                    while coinData[1] and coinData[1]:FindFirstChild("TouchInterest") and (tick() - startWait < 0.5) do
                        task.wait()
                    end
                else
                    local distance = coinData[2]
                    -- Tween directly to coin center
                    local tween = TweenService:Create(
                        player.Character.HumanoidRootPart, 
                        TweenInfo.new(distance / FARM_SPEED, Enum.EasingStyle.Linear), 
                        {CFrame = CFrame.new(coinData[1].Position)}
                    )
                    tween:Play()
                    
                    local connection
                    connection = eventfarmstopevent.Event:Connect(function()
                        tween:Cancel()
                        connection:Disconnect()
                    end)
                    
                    while coinData[1] and coinData[1]:FindFirstChild("TouchInterest") do
                        task.wait()
                    end
                    
                    tween:Cancel()
                    if connection then connection:Disconnect() end
                    task.wait(0.1)
                end
            else
                task.wait(0.3)
            end
        else
            task.wait(0.3)
        end
        task.wait(0.01)
    end
end)

-- Teleport Farm Loop
task.spawn(function()
    while true do
        if NewEventFarmStarted and isPlayerInLobby() then
            NewEventFarmIN = false
            setupFarmNoClip(false, true)
            removeAllPlatforms()
            task.wait(1)
        end

        local container = returncoincontaier()
        if NewEventFarmStarted and NewEventFarmIN and player.Character and container and player:GetAttribute("Alive") then
            if not bigPlatform then createBigPlatform() end
            if not smallPlatform then createSmallPlatform() startPlatformFollowing() end
            
            -- Gun Check handled inside wait loop of teleportToCoinAndBack, but we check here too if idle
            local acted = processAutoGun("Teleport")
            if acted then
                teleportToBigPlatform() 
            end
            
            local coinData = FindNearestCoin(container, EVENT_CURRENCY)
            if coinData[1] ~= nil then
                teleportToCoinAndBack(coinData[1].Position)
            else
                task.wait(0.3)
            end
        else
            task.wait(0.3)
        end
        task.wait(0.01)
    end
end)

-- Black screen functions
local function createBlackScreen()
    if blackScreenFrame and blackScreenFrame.Parent then blackScreenFrame:Destroy() end
    
    blackScreenFrame = Instance.new("ScreenGui")
    blackScreenFrame.Name = "BlackScreenGUI"
    blackScreenFrame.Parent = player.PlayerGui
    blackScreenFrame.DisplayOrder = 1
    blackScreenFrame.IgnoreGuiInset = true
    blackScreenFrame.ResetOnSpawn = false
    
    local fullScreenFrame = Instance.new("Frame")
    fullScreenFrame.Name = "FullScreenBlack"
    fullScreenFrame.Parent = blackScreenFrame
    fullScreenFrame.Size = UDim2.new(1, 0, 1, 0)
    fullScreenFrame.BackgroundColor3 = Color3.new(0, 0, 0)
    fullScreenFrame.BackgroundTransparency = 0
    fullScreenFrame.ZIndex = 1
    
    local centerContainer = Instance.new("Frame")
    centerContainer.Parent = fullScreenFrame
    centerContainer.Name = "CenterContainer"
    centerContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    centerContainer.Size = UDim2.new(1, 0, 1, 0)
    centerContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
    centerContainer.BackgroundTransparency = 1
    centerContainer.ZIndex = 2
    
    local optimizationText = Instance.new("TextLabel")
    optimizationText.Parent = centerContainer
    optimizationText.Text = "Optimization Enabled"
    optimizationText.Size = UDim2.new(0, 300 * SCALE_MULTIPLIER, 0, 40 * SCALE_MULTIPLIER)
    optimizationText.Position = UDim2.new(0.5, 0, 0.3, 0)
    optimizationText.AnchorPoint = Vector2.new(0.5, 0)
    optimizationText.BackgroundTransparency = 1
    optimizationText.TextColor3 = Color3.new(1, 1, 1)
    optimizationText.Font = MAIN_FONT
    optimizationText.TextSize = 32 * SCALE_MULTIPLIER
    optimizationText.ZIndex = 3
    
    local timerText = Instance.new("TextLabel")
    timerText.Parent = centerContainer
    timerText.Name = "RenderTimer"
    timerText.Text = "00:00:00"
    timerText.Size = UDim2.new(0, 350 * SCALE_MULTIPLIER, 0, 50 * SCALE_MULTIPLIER)
    timerText.Position = UDim2.new(0.5, 0, 0.45, 0)
    timerText.AnchorPoint = Vector2.new(0.5, 0)
    timerText.BackgroundTransparency = 1
    timerText.TextColor3 = Color3.new(1, 1, 1)
    timerText.Font = MAIN_FONT
    timerText.TextSize = 40 * SCALE_MULTIPLIER
    timerText.ZIndex = 3
    
    local coinsText = Instance.new("TextLabel")
    coinsText.Parent = centerContainer
    coinsText.Name = "CoinsCounter"
    coinsText.Text = "Coins collected: 0"
    coinsText.Size = UDim2.new(0, 250 * SCALE_MULTIPLIER, 0, 30 * SCALE_MULTIPLIER)
    coinsText.Position = UDim2.new(0.5, 0, 0.55, 0)
    coinsText.AnchorPoint = Vector2.new(0.5, 0)
    coinsText.BackgroundTransparency = 1
    coinsText.TextColor3 = Color3.new(1, 1, 1)
    coinsText.Font = MAIN_FONT
    coinsText.TextSize = 24 * SCALE_MULTIPLIER
    coinsText.ZIndex = 3

    return blackScreenFrame
end

local function updateBlackScreenInfo()
    if renderDisabled and blackScreenFrame then
        local fullScreenFrame = blackScreenFrame:FindFirstChild("FullScreenBlack")
        if fullScreenFrame then
            local centerContainer = fullScreenFrame:FindFirstChild("CenterContainer")
            if centerContainer then
                local timerLabel = centerContainer:FindFirstChild("RenderTimer")
                if timerLabel then
                    local elapsed = os.time() - renderStartTime
                    local hours = math.floor(elapsed / 3600)
                    local minutes = math.floor((elapsed % 3600) / 60)
                    local seconds = elapsed % 60
                    timerLabel.Text = string.format("%02d:%02d:%02d", hours, minutes, seconds)
                end
                local coinsLabel = centerContainer:FindFirstChild("CoinsCounter")
                if coinsLabel then
                    coinsLabel.Text = "Coins collected: " .. tostring(coinsCollected)
                end
            end
        end
    end
end

-- Purple colors for outline
local purpleSpectrumStroke = {
    Color3.fromRGB(138, 43, 226), Color3.fromRGB(128, 38, 216), Color3.fromRGB(118, 33, 206),
    Color3.fromRGB(108, 28, 196), Color3.fromRGB(98, 23, 186), Color3.fromRGB(88, 18, 176),
    Color3.fromRGB(78, 13, 166), Color3.fromRGB(68, 8, 156), Color3.fromRGB(58, 3, 146),
    Color3.fromRGB(48, 0, 136), Color3.fromRGB(38, 0, 126), Color3.fromRGB(28, 0, 116)
}

local function createSmoothAnimatedStroke(frame)
    local stroke = Instance.new("UIStroke")
    stroke.Parent = frame
    stroke.Color = purpleSpectrumStroke[1]
    stroke.Thickness = 2 * SCALE_MULTIPLIER
    
    local currentIndex = 1
    local direction = 1
    local step = 0.1
    local colorValue = 0
    
    coroutine.wrap(function()
        while stroke.Parent do
            local currentColor = purpleSpectrumStroke[currentIndex]
            local nextColor = purpleSpectrumStroke[currentIndex + direction] or purpleSpectrumStroke[1]
            
            stroke.Color = Color3.new(
                currentColor.R + (nextColor.R - currentColor.R) * colorValue,
                currentColor.G + (nextColor.G - currentColor.G) * colorValue,
                currentColor.B + (nextColor.B - currentColor.B) * colorValue
            )
            
            colorValue = colorValue + step
            if colorValue >= 1 then
                colorValue = 0
                currentIndex = currentIndex + direction
                if currentIndex >= #purpleSpectrumStroke then
                    currentIndex = #purpleSpectrumStroke - 1
                    direction = -1
                elseif currentIndex <= 1 then
                    currentIndex = 2
                    direction = 1
                end
            end
            task.wait(0.03)
        end
    end)()
    return stroke
end

-- GUI Creation
if player.PlayerGui:FindFirstChild("MyCustomGUI") then
    player.PlayerGui.MyCustomGUI:Destroy()
end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MyCustomGUI"
ScreenGui.Parent = player.PlayerGui
ScreenGui.ResetOnSpawn = false
ScreenGui.DisplayOrder = 100

-- Toggle Items (Optimized)
local ToggleItems = {
    {Name = "[Tween] Event Farm"},
    {Name = "[Teleport] Event Farm"},
    {Name = "Disable Rendering"}
}

local TOTAL_TOGGLES = #ToggleItems
local TOTAL_ROWS_HEIGHT = TOGGLE_TOP_MARGIN + (TOTAL_TOGGLES * LABEL_BG_HEIGHT) + ((TOTAL_TOGGLES - 1) * ROW_SPACING)
local INFO_PANEL_HEIGHT = 25 * SCALE_MULTIPLIER -- Compact info panel
local UPDATE_LOG_HEIGHT = 65 * SCALE_MULTIPLIER -- New compact height for log
local MAIN_FRAME_HEIGHT = TOTAL_ROWS_HEIGHT + INFO_PANEL_HEIGHT + UPDATE_LOG_HEIGHT + 10 * SCALE_MULTIPLIER

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = COLOR_SETTINGS.MainBackground
MainFrame.Size = UDim2.new(0, MAIN_FRAME_WIDTH, 0, MAIN_FRAME_HEIGHT)
MainFrame.Position = UDim2.new(0.5, -MAIN_FRAME_WIDTH/2, 0.5, -MAIN_FRAME_HEIGHT/2)
MainFrame.BackgroundTransparency = BACKGROUND_TRANSPARENCY
MainFrame.BorderSizePixel = 0
MainFrame.Visible = true
MainFrame.ZIndex = 100

MainFrame:GetPropertyChangedSignal("Size"):Connect(function()
    if MainFrame.AbsoluteSize.X < MINIMUM_FRAME_WIDTH then
        MainFrame.Size = UDim2.new(0, MINIMUM_FRAME_WIDTH, MainFrame.Size.Y.Scale, MainFrame.Size.Y.Offset)
    end
    -- Adjusted minimum height check
    if MainFrame.AbsoluteSize.Y < 220 * SCALE_MULTIPLIER then
        MainFrame.Size = UDim2.new(MainFrame.Size.X.Scale, MainFrame.Size.X.Offset, 0, 220 * SCALE_MULTIPLIER)
    end
end)

local MainCorner = Instance.new("UICorner")
MainCorner.Parent = MainFrame
MainCorner.CornerRadius = UDim.new(0, 15 * SCALE_MULTIPLIER)

local MainStroke = createSmoothAnimatedStroke(MainFrame)

local dragging = false
local dragInput, dragStart, startPos

local function updatePosition(input)
    if not dragging then return end
    local delta = input.Position - dragStart
    MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)

MainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then dragInput = input end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then updatePosition(input) end
end)

local Title = Instance.new("TextLabel")
Title.Parent = MainFrame
Title.Text = "Amethyst | Christmas Farm ðŸŽ„"
Title.Size = UDim2.new(1, 0, 0, 35 * SCALE_MULTIPLIER) -- Reduced title height
Title.Position = UDim2.new(0, 0, 0, 0)
Title.BackgroundTransparency = 1
Title.TextColor3 = COLOR_SETTINGS.TitleColor
Title.Font = MAIN_FONT
Title.TextSize = 20 * SCALE_MULTIPLIER
Title.ZIndex = 101

Title.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)

-- Toggle Button (Minimizer)
local ToggleButton = Instance.new("Frame")
ToggleButton.Name = "ToggleButton"
ToggleButton.Parent = ScreenGui
ToggleButton.AnchorPoint = Vector2.new(1, 0) 
ToggleButton.Size = UDim2.new(0, TOGGLE_BUTTON_SIZE, 0, TOGGLE_BUTTON_SIZE)
ToggleButton.Position = UDim2.new(1, -10, 0, 10)
ToggleButton.BackgroundColor3 = COLOR_SETTINGS.ToggleButtonBackground
ToggleButton.BorderSizePixel = 0
ToggleButton.Visible = true
ToggleButton.ZIndex = 100

local TOGGLE_BUTTON_MIN_SIZE = 35 * SCALE_MULTIPLIER
if TOGGLE_BUTTON_SIZE < TOGGLE_BUTTON_MIN_SIZE then
    ToggleButton.Size = UDim2.new(0, TOGGLE_BUTTON_MIN_SIZE, 0, TOGGLE_BUTTON_MIN_SIZE)
end

local ToggleCorner = Instance.new("UICorner")
ToggleCorner.Parent = ToggleButton
ToggleCorner.CornerRadius = UDim.new(0, 6 * SCALE_MULTIPLIER)

local ToggleStroke = createSmoothAnimatedStroke(ToggleButton)

local IconImage = Instance.new("ImageLabel")
IconImage.Name = "IconImage"
IconImage.Parent = ToggleButton
IconImage.Size = UDim2.new(0.8, 0, 0.8, 0)
IconImage.Position = UDim2.new(0.1, 0, 0.1, 0)
IconImage.BackgroundTransparency = 1
IconImage.Image = "rbxassetid://74474558059435"
IconImage.ScaleType = Enum.ScaleType.Fit
IconImage.ZIndex = 101
IconImage.Visible = true

local ToggleClickButton = Instance.new("TextButton")
ToggleClickButton.Parent = ToggleButton
ToggleClickButton.Size = UDim2.new(1, 0, 1, 0)
ToggleClickButton.BackgroundTransparency = 1
ToggleClickButton.Text = ""
ToggleClickButton.ZIndex = 102
ToggleClickButton.BorderSizePixel = 0

local function playPressAnimation()
    local originalSize = UDim2.new(0, TOGGLE_BUTTON_SIZE, 0, TOGGLE_BUTTON_SIZE)
    local shrinkSize = UDim2.new(0, TOGGLE_BUTTON_SIZE * 0.9, 0, TOGGLE_BUTTON_SIZE * 0.9)
    
    local pressTween = TweenService:Create(
        ToggleButton,
        TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Size = shrinkSize}
    )
    local returnTween = TweenService:Create(
        ToggleButton,
        TweenInfo.new(0.1, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
        {Size = originalSize}
    )
    pressTween:Play()
    pressTween.Completed:Wait()
    returnTween:Play()
end

ToggleClickButton.MouseButton1Click:Connect(function()
    playPressAnimation()
    MainFrame.Visible = not MainFrame.Visible
end)

local ToggleElements = {}

for i, item in ipairs(ToggleItems) do
    local name = item.Name
    local toggleX = MAIN_FRAME_WIDTH - TOGGLE_WIDTH - 10 * SCALE_MULTIPLIER
    local labelWidth = toggleX - 10 * SCALE_MULTIPLIER + LABEL_WIDTH_ADJUST
    
    local labelBackground = Instance.new("Frame")
    labelBackground.Name = "LabelBG_" .. name:gsub(" ", ""):gsub("%[", ""):gsub("%]", ""):gsub("/", "")
    labelBackground.Parent = MainFrame
    labelBackground.Size = UDim2.new(0, labelWidth, 0, LABEL_BG_HEIGHT)
    labelBackground.Position = UDim2.new(0, 10 * SCALE_MULTIPLIER, 0, TOGGLE_TOP_MARGIN + (i-1)*(LABEL_BG_HEIGHT + ROW_SPACING))
    labelBackground.BackgroundColor3 = COLOR_SETTINGS.LabelBackground
    labelBackground.BackgroundTransparency = LABEL_BG_TRANSPARENCY
    labelBackground.BorderSizePixel = 0
    labelBackground.ZIndex = 101
    
    local labelBGCorner = Instance.new("UICorner")
    labelBGCorner.Parent = labelBackground
    labelBGCorner.CornerRadius = UDim.new(0, LABEL_BG_CORNER_RADIUS)
    
    local iconCircle = Instance.new("Frame")
    iconCircle.Parent = labelBackground
    iconCircle.Name = "IconCircle"
    iconCircle.Size = UDim2.new(0, ICON_CIRCLE_SIZE, 0, ICON_CIRCLE_SIZE)
    iconCircle.Position = UDim2.new(0, ICON_CIRCLE_OFFSETS[name] or 0, 0, 0)
    iconCircle.BackgroundColor3 = COLOR_SETTINGS.IconCircle
    iconCircle.BackgroundTransparency = 0.3
    iconCircle.ZIndex = 102
    
    local iconCircleCorner = Instance.new("UICorner")
    iconCircleCorner.Parent = iconCircle
    iconCircleCorner.CornerRadius = UDim.new(1, 0)
    
    local icon = Instance.new("ImageLabel")
    icon.Parent = iconCircle
    icon.Name = "Icon"
    icon.Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
    icon.Position = UDim2.new(0.5, -ICON_SIZE/2, 0.5, -ICON_SIZE/2)
    icon.BackgroundTransparency = 1
    icon.Image = "rbxassetid://" .. tostring(ASSET_IDS[name])
    icon.ScaleType = Enum.ScaleType.Fit
    icon.ZIndex = 103
    
    local label = Instance.new("TextLabel")
    label.Parent = labelBackground
    label.Text = name
    label.Size = UDim2.new(1, -(ICON_CIRCLE_SIZE + (ICON_CIRCLE_OFFSETS[name] or 0) + 8 * SCALE_MULTIPLIER), 1, 0)
    label.Position = UDim2.new(0, ICON_CIRCLE_SIZE + (ICON_CIRCLE_OFFSETS[name] or 0) + 4 * SCALE_MULTIPLIER, 0, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = COLOR_SETTINGS.TextColor
    label.Font = MAIN_FONT
    label.TextSize = LABEL_FONT_SIZE
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.ZIndex = 101
    
    local toggleFrame = Instance.new("Frame")
    toggleFrame.Name = "Toggle_" .. name:gsub(" ", ""):gsub("%[", ""):gsub("%]", ""):gsub("/", "")
    toggleFrame.Parent = MainFrame
    toggleFrame.Size = UDim2.new(0, TOGGLE_WIDTH, 0, TOGGLE_HEIGHT)
    toggleFrame.Position = UDim2.new(0, toggleX, 0, TOGGLE_TOP_MARGIN + (i-1)*(LABEL_BG_HEIGHT + ROW_SPACING) + (LABEL_BG_HEIGHT - TOGGLE_HEIGHT)/2)
    toggleFrame.BackgroundColor3 = COLOR_SETTINGS.ToggleOff
    toggleFrame.BorderSizePixel = 0
    toggleFrame.ZIndex = 101
    
    local round = Instance.new("UICorner")
    round.Parent = toggleFrame
    round.CornerRadius = UDim.new(0, TOGGLE_CORNER_RADIUS)
    
    local circle = Instance.new("Frame")
    circle.Name = "circle"
    circle.Parent = toggleFrame
    circle.AnchorPoint = Vector2.new(0, 0.5)
    circle.Size = UDim2.new(0, TOGGLE_CIRCLE_SIZE, 0, TOGGLE_CIRCLE_SIZE)
    circle.Position = UDim2.new(0, 3 * SCALE_MULTIPLIER, 0.5, 0)
    circle.BackgroundColor3 = COLOR_SETTINGS.ToggleCircleOff
    circle.BorderSizePixel = 0
    circle.ZIndex = 102
    
    local roundCircle = Instance.new("UICorner")
    roundCircle.Parent = circle
    roundCircle.CornerRadius = UDim.new(1, 0)
    
    local clickButton = Instance.new("TextButton")
    clickButton.Parent = toggleFrame
    clickButton.Size = UDim2.new(1, 0, 1, 0)
    clickButton.BackgroundTransparency = 1
    clickButton.Text = ""
    clickButton.ZIndex = 103
    clickButton.BorderSizePixel = 0
    
    local toggled = false

    local function toggle()
        toggled = not toggled
        
        if ToggleElements[name] then
            ToggleElements[name].toggled = toggled
        end

        -- === MUTUAL EXCLUSION CHECK ===
        if toggled then
            if name == "[Tween] Event Farm" then
                if NewEventFarmStarted then
                    local other = ToggleElements["[Teleport] Event Farm"]
                    if other and other.toggleFunction then
                        other.toggleFunction()
                    end
                end
            elseif name == "[Teleport] Event Farm" then
                if EventFarmStarted then
                    local other = ToggleElements["[Tween] Event Farm"]
                    if other and other.toggleFunction then
                        other.toggleFunction()
                    end
                end
            end
        end

        TweenService:Create(toggleFrame, TweenInfo.new(TOGGLE_ANIMATION_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = toggled and COLOR_SETTINGS.ToggleOn or COLOR_SETTINGS.ToggleOff}):Play()
        local targetX = toggled and (TOGGLE_WIDTH - TOGGLE_CIRCLE_SIZE - 3 * SCALE_MULTIPLIER) or 3 * SCALE_MULTIPLIER
        TweenService:Create(circle, TweenInfo.new(TOGGLE_ANIMATION_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0, targetX, 0.5, 0)}):Play()
        TweenService:Create(circle, TweenInfo.new(TOGGLE_ANIMATION_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundColor3 = toggled and COLOR_SETTINGS.ToggleCircleOn or COLOR_SETTINGS.ToggleCircleOff}):Play()
        
        if name == "[Tween] Event Farm" then
            if toggled then
                EventFarmStarted = true
                SetupAntiAFK(true)
                isFirstTween = true 
                if returncoincontaier() and player:GetAttribute("Alive") and not isPlayerInLobby() then
                    EventFarmIN = true
                    setupFarmNoClip(true, false)
                else
                    EventFarmIN = false 
                end
            else
                EventFarmStarted = false
                EventFarmIN = false
                eventfarmstopevent:Fire()
                SetupAntiAFK(false)
                setupFarmNoClip(false, false)
            end
        elseif name == "[Teleport] Event Farm" then
            if toggled then
                NewEventFarmStarted = true
                SetupAntiAFK(true)
                if returncoincontaier() and player:GetAttribute("Alive") and not isPlayerInLobby() then
                    NewEventFarmIN = true
                    setupFarmNoClip(true, true)
                    createBigPlatform()
                    createSmallPlatform()
                    startPlatformFollowing()
                    task.wait(0.5)
                    teleportToBigPlatform()
                else
                    NewEventFarmIN = false 
                end
            else
                NewEventFarmStarted = false
                NewEventFarmIN = false
                neweventfarmstopevent:Fire()
                SetupAntiAFK(false)
                setupFarmNoClip(false, true)
                removeAllPlatforms()
            end
        elseif name == "Disable Rendering" then
            if toggled then
                renderDisabled = true
                renderStartTime = os.time()
                RunService:Set3dRenderingEnabled(false)
                createBlackScreen()
                task.spawn(function()
                    while renderDisabled do
                        updateBlackScreenInfo()
                        task.wait(1)
                    end
                end)
            else
                renderDisabled = false
                if blackScreenFrame then blackScreenFrame:Destroy() blackScreenFrame = nil end
                RunService:Set3dRenderingEnabled(true)
            end
        end
    end

    clickButton.MouseButton1Click:Connect(function() toggle() end)
    ToggleElements[name] = {frame = toggleFrame, circle = circle, toggled = toggled, toggleFunction = toggle}
end

local lastToggleY = TOGGLE_TOP_MARGIN + ((#ToggleItems - 1) * (LABEL_BG_HEIGHT + ROW_SPACING)) + LABEL_BG_HEIGHT + 3 * SCALE_MULTIPLIER

-- === INFO PANEL (AFK + TIMER) ===
local InfoPanel = Instance.new("Frame")
InfoPanel.Name = "InfoPanel"
InfoPanel.Parent = MainFrame
InfoPanel.BackgroundTransparency = 1
InfoPanel.Size = UDim2.new(1, -20 * SCALE_MULTIPLIER, 0, INFO_PANEL_HEIGHT)
InfoPanel.Position = UDim2.new(0, 10 * SCALE_MULTIPLIER, 0, lastToggleY)
InfoPanel.Visible = true
InfoPanel.ZIndex = 101

local AntiAFKText = Instance.new("TextLabel")
AntiAFKText.Name = "AntiAFKText"
AntiAFKText.Parent = InfoPanel
AntiAFKText.Size = UDim2.new(0.6, 0, 1, 0)
AntiAFKText.Position = UDim2.new(0, 0, 0, 0)
AntiAFKText.BackgroundTransparency = 1
AntiAFKText.Font = MAIN_FONT
AntiAFKText.TextSize = 14 * SCALE_MULTIPLIER
AntiAFKText.TextXAlignment = Enum.TextXAlignment.Left
AntiAFKText.TextColor3 = COLOR_SETTINGS.TextColor
AntiAFKText.Visible = true
AntiAFKText.ZIndex = 101

local GameTimeStatus = Instance.new("TextLabel")
GameTimeStatus.Name = "GameTimeStatus"
GameTimeStatus.Parent = InfoPanel
GameTimeStatus.Size = UDim2.new(0.4, 0, 1, 0)
GameTimeStatus.Position = UDim2.new(0.6, 0, 0, 0)
GameTimeStatus.BackgroundTransparency = 1
GameTimeStatus.Font = MAIN_FONT
GameTimeStatus.TextSize = 14 * SCALE_MULTIPLIER
GameTimeStatus.TextXAlignment = Enum.TextXAlignment.Right
GameTimeStatus.TextColor3 = COLOR_SETTINGS.TextColor
GameTimeStatus.Visible = true
GameTimeStatus.ZIndex = 101

-- === UPDATE LOG SECTION ===
local updateLogY = lastToggleY + INFO_PANEL_HEIGHT + 3 * SCALE_MULTIPLIER

local UpdateLogFrame = Instance.new("Frame")
UpdateLogFrame.Name = "UpdateLogFrame"
UpdateLogFrame.Parent = MainFrame
UpdateLogFrame.Size = UDim2.new(1, -20 * SCALE_MULTIPLIER, 0, UPDATE_LOG_HEIGHT)
UpdateLogFrame.Position = UDim2.new(0, 10 * SCALE_MULTIPLIER, 0, updateLogY)
UpdateLogFrame.BackgroundColor3 = COLOR_SETTINGS.LabelBackground
UpdateLogFrame.BackgroundTransparency = LABEL_BG_TRANSPARENCY
UpdateLogFrame.BorderSizePixel = 0
UpdateLogFrame.ZIndex = 101

local LogCorner = Instance.new("UICorner")
LogCorner.CornerRadius = UDim.new(0, LABEL_BG_CORNER_RADIUS)
LogCorner.Parent = UpdateLogFrame

local LogTitle = Instance.new("TextLabel")
LogTitle.Parent = UpdateLogFrame
LogTitle.Text = "Change Log"
LogTitle.Size = UDim2.new(1, 0, 0, 20 * SCALE_MULTIPLIER)
LogTitle.Position = UDim2.new(0, 0, 0, 2 * SCALE_MULTIPLIER) -- Top padding 2
LogTitle.BackgroundTransparency = 1
LogTitle.TextColor3 = COLOR_SETTINGS.TextColor
LogTitle.Font = MAIN_FONT
LogTitle.TextSize = 14 * SCALE_MULTIPLIER
LogTitle.ZIndex = 102

local LogContent = Instance.new("TextLabel")
LogContent.Parent = UpdateLogFrame
LogContent.Text = "â€¢ Murder / Sheriff fling\nâ€¢ Removed Auto Reset toggle\nâ€¢ Auto Reset is included in farm"
LogContent.Size = UDim2.new(1, -10 * SCALE_MULTIPLIER, 1, -22 * SCALE_MULTIPLIER)
LogContent.Position = UDim2.new(0, 5 * SCALE_MULTIPLIER, 0, 20 * SCALE_MULTIPLIER) -- Below title
LogContent.BackgroundTransparency = 1
LogContent.TextColor3 = COLOR_SETTINGS.TextColor
LogContent.Font = Enum.Font.SourceSans
LogContent.TextSize = 12 * SCALE_MULTIPLIER -- Small text
LogContent.TextXAlignment = Enum.TextXAlignment.Left
LogContent.TextYAlignment = Enum.TextYAlignment.Top
LogContent.ZIndex = 102
-- ============================

local startTime = tick()

local function formatTime(seconds)
    local hours = math.floor(seconds / 3600)
    local minutes = math.floor((seconds % 3600) / 60)
    local secs = math.floor(seconds % 60)
    return string.format("%02d:%02d:%02d", hours, minutes, secs)
end

local function updateInfoPanel()
    if AntiAFKEnabled then
        AntiAFKText.Text = "AntiAfk: Active"
        AntiAFKText.TextColor3 = COLOR_SETTINGS.AntiAFKActive
    else
        AntiAFKText.Text = "AntiAfk: Inactive"
        AntiAFKText.TextColor3 = COLOR_SETTINGS.AntiAFKInactive
    end
    local elapsedTime = tick() - startTime
    GameTimeStatus.Text = formatTime(elapsedTime)
end

task.spawn(function()
    while true do
        updateInfoPanel()
        task.wait(1)
    end
end)
